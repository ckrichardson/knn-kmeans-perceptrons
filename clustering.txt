Contrary to the perceptron implementation, due to time constraints, the code of K-means has signficantly reduced readability, but it is functional...

The idea of a k-means is simple:   choose cluster centers, find clusters, then update cluster centers.   This process is continued until the cluster centers remain the same (aka they do not get updated anymore).   In the function K_Means, we aim to accomplish this through through extensive use of numpy arrays, array manipulation, and helper functions.   It first starts off by declaring a lot of variables that will be necessary to support the intermediary processes, such as the clusters array, the centers array, and a boolean called "changing" that indicates whether the cluster centers are changing.   After the declaration and intiialization of these items, we proceed to a while loop that will select (without replacement) three numbers from the sample to serve as the inital cluster centers.   After this process has executed, the program will enter the succeeding while loop, which shall run until cluster centers do not change anymore.   Inside this while loop, there are two helper functions:   calculate_clusters, and recalculate_centers.   Calculate clusters is a function which, given a point, evaluates the closest cluster center.   This is done for all points in the data, and the results are stored in an array of the size of the training data.   Once this is accomplished, recalculate_centers is invoked.   To it are passed the data points, the current centers, and the recently evaluated clusters.   Inside of the recalculate_centers function, we simply take the average of all data that exists in each cluster.   These will serve as the new cluster centers in the upcoming iteration.   Once this is finished, a conditional statement checks whether or not the outgoing cluster centers were identical with the ones that were passed to the function.   If they were, the function returns two things:   the centers, and a boolean false.   Otherwise, it returns the centers, and a boolean true.   The idea is that this is the mechanism that will determine whether the k-means algorithm itself should continue executing, or it should not continue anymore.   

Finally, after there are no changes to the cluster centers, the function will return an array of the final set of cluster centers.


For K_Means better, we use a very simple method to determine the best K_means centers.   We take our dataset, run the K_means algorithm 1000 times over it, and observe all the resultant cluster centers to see which one of them was outputted the most.   This will ignore the ordering of the arrays (as long as they have the same centers, it does not matter which order they are in).   The function simply executes this calculation, then returns the most prevalent set of centers.   